{"ast":null,"code":"\"use strict\";\n/*\n * $asyncbind has multiple uses, depending on the parameter list. It is in Function.prototype, so 'this' is always a function\n *\n * 1) If called with a single argument (this), it is used when defining an async function to ensure when\n *      it is invoked, the correct 'this' is present, just like \"bind\". For legacy reasons, 'this' is given\n *      a memeber 'then' which refers to itself.\n * 2) If called with a second parameter (\"catcher\") and catcher!==true it is being used to invoke an async\n *      function where the second parameter is the error callback (for sync exceptions and to be passed to\n *      nested async calls)\n * 3) If called with the second parameter===true, it is the same use as (1), but the function is wrapped\n *      in an 'Promise' as well bound to 'this'.\n *      It is the same as calling 'new Promise(this)', where 'this' is the function being bound/wrapped\n * 4) If called with the second parameter===0, it is the same use as (1), but the function is wrapped\n *      in a 'LazyThenable', which executes lazily and can resolve synchronously.\n *      It is the same as calling 'new LazyThenable(this)' (if such a type were exposed), where 'this' is\n *      the function being bound/wrapped\n */\n\nfunction processIncludes(includes, input) {\n  var src = input.toString();\n  var t = \"return \" + src;\n  var args = src.match(/.*\\(([^)]*)\\)/)[1];\n  var re = /['\"]!!!([^'\"]*)['\"]/g;\n  var m = [];\n\n  while (1) {\n    var mx = re.exec(t);\n    if (mx) m.push(mx);else break;\n  }\n\n  m.reverse().forEach(function (e) {\n    t = t.slice(0, e.index) + includes[e[1]] + t.substr(e.index + e[0].length);\n  });\n  t = t.replace(/\\/\\*[^*]*\\*\\//g, ' ').replace(/\\s+/g, ' ');\n  return new Function(args, t)();\n}\n\nvar $asyncbind = processIncludes({\n  zousan: require('./zousan').toString(),\n  thenable: require('./thenableFactory').toString()\n}, function $asyncbind(self, catcher) {\n  \"use strict\";\n\n  if (!Function.prototype.$asyncbind) {\n    Object.defineProperty(Function.prototype, \"$asyncbind\", {\n      value: $asyncbind,\n      enumerable: false,\n      configurable: true,\n      writable: true\n    });\n  }\n\n  if (!$asyncbind.trampoline) {\n    $asyncbind.trampoline = function trampoline(t, x, s, e, u) {\n      return function b(q) {\n        while (q) {\n          if (q.then) {\n            q = q.then(b, e);\n            return u ? undefined : q;\n          }\n\n          try {\n            if (q.pop) {\n              if (q.length) return q.pop() ? x.call(t) : q;\n              q = s;\n            } else q = q.call(t);\n          } catch (r) {\n            return e(r);\n          }\n        }\n      };\n    };\n  }\n\n  if (!$asyncbind.LazyThenable) {\n    $asyncbind.LazyThenable = '!!!thenable'();\n    $asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = '!!!zousan')();\n  }\n\n  function boundThen() {\n    return resolver.apply(self, arguments);\n  }\n\n  var resolver = this;\n\n  switch (catcher) {\n    case true:\n      return new $asyncbind.Thenable(boundThen);\n\n    case 0:\n      return new $asyncbind.LazyThenable(boundThen);\n\n    case undefined:\n      /* For runtime compatibility with Nodent v2.x, provide a thenable */\n      boundThen.then = boundThen;\n      return boundThen;\n\n    default:\n      return function () {\n        try {\n          return resolver.apply(self, arguments);\n        } catch (ex) {\n          return catcher(ex);\n        }\n      };\n  }\n});\n\nfunction $asyncspawn(promiseProvider, self) {\n  if (!Function.prototype.$asyncspawn) {\n    Object.defineProperty(Function.prototype, \"$asyncspawn\", {\n      value: $asyncspawn,\n      enumerable: false,\n      configurable: true,\n      writable: true\n    });\n  }\n\n  if (!(this instanceof Function)) return;\n  var genF = this;\n  return new promiseProvider(function enough(resolve, reject) {\n    var gen = genF.call(self, resolve, reject);\n\n    function step(fn, arg) {\n      var next;\n\n      try {\n        next = fn.call(gen, arg);\n\n        if (next.done) {\n          if (next.value !== resolve) {\n            if (next.value && next.value === next.value.then) return next.value(resolve, reject);\n            resolve && resolve(next.value);\n            resolve = null;\n          }\n\n          return;\n        }\n\n        if (next.value.then) {\n          next.value.then(function (v) {\n            step(gen.next, v);\n          }, function (e) {\n            step(gen.throw, e);\n          });\n        } else {\n          step(gen.next, next.value);\n        }\n      } catch (e) {\n        reject && reject(e);\n        reject = null;\n        return;\n      }\n    }\n\n    step(gen.next);\n  });\n} // Initialize async bindings\n\n\n$asyncbind();\n$asyncspawn(); // Export async bindings\n\nmodule.exports = {\n  $asyncbind: $asyncbind,\n  $asyncspawn: $asyncspawn\n};","map":{"version":3,"sources":["/home/thomas/Map-interactive/node_modules/nodent-runtime/runtime.js"],"names":["processIncludes","includes","input","src","toString","t","args","match","re","m","mx","exec","push","reverse","forEach","e","slice","index","substr","length","replace","Function","$asyncbind","zousan","require","thenable","self","catcher","prototype","Object","defineProperty","value","enumerable","configurable","writable","trampoline","x","s","u","b","q","then","undefined","pop","call","r","LazyThenable","EagerThenable","Thenable","EagerThenableFactory","boundThen","resolver","apply","arguments","ex","$asyncspawn","promiseProvider","genF","enough","resolve","reject","gen","step","fn","arg","next","done","v","throw","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * $asyncbind has multiple uses, depending on the parameter list. It is in Function.prototype, so 'this' is always a function\n *\n * 1) If called with a single argument (this), it is used when defining an async function to ensure when\n *      it is invoked, the correct 'this' is present, just like \"bind\". For legacy reasons, 'this' is given\n *      a memeber 'then' which refers to itself.\n * 2) If called with a second parameter (\"catcher\") and catcher!==true it is being used to invoke an async\n *      function where the second parameter is the error callback (for sync exceptions and to be passed to\n *      nested async calls)\n * 3) If called with the second parameter===true, it is the same use as (1), but the function is wrapped\n *      in an 'Promise' as well bound to 'this'.\n *      It is the same as calling 'new Promise(this)', where 'this' is the function being bound/wrapped\n * 4) If called with the second parameter===0, it is the same use as (1), but the function is wrapped\n *      in a 'LazyThenable', which executes lazily and can resolve synchronously.\n *      It is the same as calling 'new LazyThenable(this)' (if such a type were exposed), where 'this' is\n *      the function being bound/wrapped\n */\n\nfunction processIncludes(includes,input) {\n    var src = input.toString() ;\n    var t = \"return \"+src ;\n    var args = src.match(/.*\\(([^)]*)\\)/)[1] ;\n    var re = /['\"]!!!([^'\"]*)['\"]/g ;\n    var m = [] ;\n    while (1) {\n        var mx = re.exec(t) ;\n        if (mx)\n            m.push(mx) ;\n        else break ;\n    }\n    m.reverse().forEach(function(e){\n        t = t.slice(0,e.index)+includes[e[1]]+t.substr(e.index+e[0].length) ;\n    }) ;\n    t = t.replace(/\\/\\*[^*]*\\*\\//g,' ').replace(/\\s+/g,' ') ;\n    return new Function(args,t)() ;\n}\n\nvar $asyncbind = processIncludes({\n    zousan:require('./zousan').toString(),\n    thenable:require('./thenableFactory').toString()\n},\nfunction $asyncbind(self,catcher) {\n    \"use strict\";\n    if (!Function.prototype.$asyncbind) {\n        Object.defineProperty(Function.prototype,\"$asyncbind\",{value:$asyncbind,enumerable:false,configurable:true,writable:true}) ;\n    }\n\n    if (!$asyncbind.trampoline) {\n      $asyncbind.trampoline = function trampoline(t,x,s,e,u){\n        return function b(q) {\n                while (q) {\n                    if (q.then) {\n                        q = q.then(b, e) ;\n                        return u?undefined:q;\n                    }\n                    try {\n                        if (q.pop) {\n                            if (q.length)\n                              return q.pop() ? x.call(t) : q;\n                            q = s;\n                         } else\n                            q = q.call(t)\n                    } catch (r) {\n                        return e(r);\n                    }\n                }\n            }\n        };\n    }\n    if (!$asyncbind.LazyThenable) {\n        $asyncbind.LazyThenable = '!!!thenable'();\n        $asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = '!!!zousan')();\n    }\n\n    function boundThen() {\n        return resolver.apply(self,arguments);\n    }\n\n    var resolver = this;\n    switch (catcher) {\n    case true:\n        return new ($asyncbind.Thenable)(boundThen);\n    case 0:\n        return new ($asyncbind.LazyThenable)(boundThen);\n    case undefined:\n        /* For runtime compatibility with Nodent v2.x, provide a thenable */\n        boundThen.then = boundThen ;\n        return boundThen ;\n    default:\n        return function(){\n            try {\n                return resolver.apply(self,arguments);\n            } catch(ex) {\n                return catcher(ex);\n            }\n        }\n    }\n\n}) ;\n\nfunction $asyncspawn(promiseProvider,self) {\n    if (!Function.prototype.$asyncspawn) {\n        Object.defineProperty(Function.prototype,\"$asyncspawn\",{value:$asyncspawn,enumerable:false,configurable:true,writable:true}) ;\n    }\n    if (!(this instanceof Function)) return ;\n\n    var genF = this ;\n    return new promiseProvider(function enough(resolve, reject) {\n        var gen = genF.call(self, resolve, reject);\n        function step(fn,arg) {\n            var next;\n            try {\n                next = fn.call(gen,arg);\n                if(next.done) {\n                    if (next.value !== resolve) {\n                        if (next.value && next.value===next.value.then)\n                            return next.value(resolve,reject) ;\n                        resolve && resolve(next.value);\n                        resolve = null ;\n                    }\n                    return;\n                }\n\n                if (next.value.then) {\n                    next.value.then(function(v) {\n                        step(gen.next,v);\n                    }, function(e) {\n                        step(gen.throw,e);\n                    });\n                } else {\n                    step(gen.next,next.value);\n                }\n            } catch(e) {\n                reject && reject(e);\n                reject = null ;\n                return;\n            }\n        }\n        step(gen.next);\n    });\n}\n\n// Initialize async bindings\n$asyncbind() ;\n$asyncspawn() ;\n\n// Export async bindings\nmodule.exports = {\n    $asyncbind:$asyncbind,\n    $asyncspawn:$asyncspawn\n};\n"]},"metadata":{},"sourceType":"script"}